---
layout: post
title:  "디자인패턴 7장 정리"
date:   now()
categories: study review
---

## 디자인 패턴 7장 

### 주요 디자인 패턴

#### 디자인 패턴 이란?

- 상황에 맞는 올바른 설계를 더 빠르게 적용
- 각 패턴의 장단점을 통해서 설계를 선택하는데 도움
- 설계 패턴에 네이밍하면서 시스템의 문서화, 이해, 유지 보수에 도움



#### 전략 패턴

- 특정 콘텍스트에서 알고리즘(전략)을 별도로 분리하는 설계

  - EX) 할인 정책(첫 고객 할인, 품질 나쁜 상품 할인 등)

- 콘텍스트의 클라이언트가 전략의 상세 구현을 알게 됨

  - 전략의 콘크리트 클래스와 클라이언트의 코드가 쌍을 이루어 유지 보수에 용이함

- 코드의 변경 없이 새로운 정책을 추가 가능

- 확장에는 열려있고 변경에는 닫혀 있는 개방-폐쇄 원칙 따름

- if-else 구조의 비슷한 기능을 수행하는 경우 전략 패턴 적용 용이

- 완전히 동일한 기능을 제공하지만 성능의 장단저에 따라 알고리즘을 선택하는 경우 사용

  - XML 파싱 후 객체 생성

  

#### 템플릿 메서드 패턴

- 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용

- 템플릿 메서드 패턴의 구성

  - 실행 과정을 구현한 상위 클래스
  - 실행 과정의 일부 단계를 구현한 하위 클래스
  - 추상 클래스에 동일 실행 과정은 구현하고 차이나는 부분은 별도의 추상 메소드로 분리

- 코드의 중복 문제를 제거하면서 코드를 재사용 할 수 있음

- 상위 클래스가 흐름 제어의 주체

  - 이러한 메소드를 훅(hook) 메서드라고 함

- 템플릿 메서드 패턴과 전략 패턴을 조합 사용의 특징

  - 템플릿 메서드와 비교하여 유연함
  - 불필요한 클래스의 생성을 방지
  - 조립/위임을 사용하여 런타임에 사용 할 객체를 교체 가능
  - 구현이 복잡해 질 수 있음

  

#### 상태 패턴

- 상태에 따라 동일한 기능 요청의 처리를 다르게 할 때 사용
- 상태를 별도의 타입으로 분리하고 각 상태에 따라 알맞은 하위 타입을 구성
  - 동일한 기능 요청을 인터페이스로 정의
  - 각 상태 타입이 자신의 상태일 때의 기능을 정의
- 상태 패턴의 장점
  - 새로운 상태가 추가 되어도 기존의 코드가 받는 영향은 최소화
  - 상태에 따른 기능이 각 상태 별로 구분되기에 상태 별 동작 수정이 용이
- 상태 변경 주체의 선택
  - 콘텍스트
    - 비교적 상태의 갯수가 적고 상태 변경 규칙이 거의 바뀌지 않을 경우
  - 상태 객체
    - 콘텍스트 선택의 경우와 반대로



#### 데코레이터 패턴

- 상속을 이용하여 기능 확장을 할 때, 불필요한 클래스 수의 증가 문제가 있음.
- 상속이 아닌 위임 방식으로 기능을 확장해나가는 것이 데코레이터 패턴
- Decorator 클래스는 인터페이스를 상속받고 기능 사용을 위해 내부 객체를 생성하여 상위 기능 실행을 위임
- 각 확장 기능 클래스 Decorator 클래스를 상속받고 자신의 기능들을 수행한 뒤 상속 객체에 상위기능 수행을 위임
- 사용 방법
  - FileOut delegate = new FileOutImpl();
  - FileOut fileOut = new EncryptionOut(new ZipOut(delegate));
  - fileOut.write(data)
  - 암호화 및 압축한 데이터를 쓰기
- 적용 시 고려할 점
  - 테코레이터 대상이 되는 타입의 기능 개수
    - 인터페이스에 정의되어 있는 메서드가 많으면 데코레이터의 구현이 복잡해짐
  - 테코레이터 객체가 비정상적으로 동작할 때 어떻게 처리할 것인지



#### 프록시 패턴

- 목록을 구성할 때 스크롤 내리지 않으면 보이지 않는 부분까지 출력해 놓는 것은 불필요하게 메모리를 사용
- 스크롤을 내려 이미지가 실제로 화면에 보여질 때 이미지 데이터를 로딩하는 방법
- 필요한 순간에 실제 객체를 생성해 주는 프록시를 "가상 프록시" 라고 함
- 프록시 패턴을 적용할 때 고려 사항
  - 객체를 누가 생성할 것이냐



#### 어댑터 패턴

- 클라이언트가 요구하는 인터페이스와 재사용 하려는 모듈의 인터페이스가 일치하지 않을 때 사용하는 패턴

- 클라이언트가 요구하는 인터페이스의 메서드를 오버라이딩 하여 사용하려는 모듈의 메서드를 사용하여 요구 사항에 맞게 맞춰주는 클래스

  

#### 옵저버 패턴

- 한 객체의 상태 변화를 정해지지 않은 여러 다른 객체에게 통지하고 싶을 때 사용
- 주체와 옵저버 객체로 구성
- 주체 객체가 가지는 책임
  - 옵저버 목록을 관리하고 옵저버를 등록하고 제거할 수 있는 메서드 제공
    - add(), remove()
  - 상태의 변경이 발생하면 등록된 옵저버에 변경 내역을 알림
    - notifyStatus(), onAbnormlStatus()
- StatusChecker는 주체 객체를 상속받고 상태 변화가 감지되면 상위 클래스의 onAbnormlStatus() 호출
- 

------------- 추가예정..---------



#### 미디에이터 패턴

#### 파사드 패턴

#### 추상팩토리 패턴

#### 컴포지트 패턴

#### 널 패턴